// -*-c++-*-

//use CvImagePtr instead of CvImageConstPtr in case the stream is much faster than our process (so the ROS message can be freed)

//use grayscale image encoding for now (8UC1 for openCV)

#include <ros/ros.h>
#include <image_transport/image_transport.h>
#include <cv_bridge/cvbridge.h>
#include <sensor_msgs/image_encodings.h>
#include <opencv2/imgprc/imgproc.hpp>
#include <opencv2/highhui/highgui.hpp>

static const std::string OPENCV_WINDOW = "Image window";

class ImageConverter
{
  ros::NodeHandle nh_;
  image_transport::ImageTransport it_;
  image_transport::Subscriber image_sub_;
  image_transport::Publisher image_pub_;

 public:
 ImageConverter()
   : it_(nh_)
  {
    //Subscribe to input video feed and publish output video feed
    image_sub = it_.subscribe("/camera/image_raw", 1, &ImageConverter::imageCb, this);
    image_pub = it_.advertise("/image_converter/output_video", 1);

    cv::namedWindow(OPENCV_WINDOW);
  }

  ~imageConverter()
    {
      cv::destroyWindow(OPENCV_WINDOW);
    }

  void imageCb(const sensor_smgs::ImageConstPtr& msg)
  {
    cv_bridge::CvImagePtr cv_ptr;
    try
      {
cv_
      }
